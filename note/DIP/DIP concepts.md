### DIP concepts

####   convolution and linear filter

~~~ python
线性滤波可以说是图像处理最基本的方法， 它可以允许我们对图像进行处理，产生不同的效果。 
1.首先我们创建一个二维滤波器矩阵（卷积核）， 和一个需要处理的二维图像，然后我们对于图像的每一个像素点，计算它和邻域像素和卷积核的对应元素的乘积，最后加起来作为该元素的值， 这就是我们说的滤波过程。见convolution图 
对图像和滤波矩阵进行逐个元素相乘再求和的操作就相当于将一个二维的函数移动到另一个二维函数的所有位置，这个操作就叫卷积或者协相关。卷积和协相关的差别是，卷积需要先对滤波矩阵进行180的翻转，但如果矩阵是对称的，那么两者就没有什么差别了。
2.correlation 和 convolution 两个非常关键的特点：它们是线性的，而且具有平移不变性shift-invariant。平移不变性指我们在图像的每个位置都执行相同的操作。线性指这个操作是线性的，也就是我们用每个像素的邻域的线性组合来代替这个像素。这两个属性使得这个操作非常简单，因为线性操作是最简单的，然后在所有地方都做同样的操作就更简单了。
3.对于滤波器具有一定的规则要求：
(1)滤波器的大小应该是"奇数"，这样它才有一个中心，例如3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。
(2)滤波器矩阵所有的元素之和应该要"等于1"，这是为了保证滤波前后图像的亮度保持不变。当然了，这不是硬性要求了。
(3)如果滤波器矩阵所有元素之和"大于1"，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗.
(4)对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。
4.卷积的相关操作：锐化，模糊
如果滤波器的中心点是1， 其他邻域点的权值是0，那么在滤波后没有任何影响，因为邻域的值为0 相加之后没有对中心点的值产生任何影响。
（1）图像锐化：
图像的锐化和边缘检测很像，首先"找到边缘"，然后把"边缘加到原来的图像上面"，这样就强化了图像的边缘，使图像看起来更加锐利了。这两者操作统一起来就是锐化滤波器了，也就是在边缘检测滤波器的基础上，再在中心的位置加1，这样滤波后的图像就会和原始的图像具有同样的亮度了，但是会更加锐利。
（2）边缘检测
我们要找水平的边缘：需要注意的是，这里矩阵的元素和是0，所以滤波后的图像会很暗，只有边缘的地方是有亮度的。为了检测边缘，我们需要在图像对应的方向计算梯度。但在实际中，这种简单的方法会把噪声也放大了。
（3）均值模糊
我们可以将当前像素和它的四邻域的像素一起取平均，然后再除以5，或者直接在滤波器的5个地方取0.2的值即可
（4）高斯模糊
其实模糊滤波器就是对周围像素进行加权平均处理，均值模糊很简单，周围像素的权值都相同，所以不是很平滑。高斯模糊使用了模糊器的优点，所以被广泛用在图像降噪上。特别是在边缘检测之前，都会用来移除细节。那么下面我们就看看高斯模糊的权值是如何分配的。
declaration：https://blog.csdn.net/weixin_42026802/article/details/80181627?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161354265516780271560223%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161354265516780271560223&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-80181627.first_rank_v2_pc_rank_v29&utm_term=%25E5%259B%25BE%25E5%2583%258F%25E5%25A4%2584%25E7%2590%2586


~~~

#### HISTOGRAM

~~~ PYTHON
直方图：一幅图像由不同灰度值的像素组成，图像中灰度的分布情况是该图像的一个重要特征。图像的灰度直方图就描述了图像中灰度分布情况，能够很直观的展示出图像中各个灰度级所占的多少。图像的灰度直方图是灰度级的函数，描述的是图像中具有该灰度级的像素的个数：其中，横坐标是灰度级，纵坐标是该灰度级出现的频率。
histogram normalization:直方图归一化：有些灰度图像的像素并没有分布在 [0,255] 内，而是分布在 [0,255] 的子区间内。这样的图像肉眼看上去往往不是很清晰。我们可以通过直方图归一化的方式，将它的像素分布从 [0,255] 的子区间变为 [0,255] 范围内。通过这样的方式，往往可以增加图像的清晰度
"直方图的优点"：直方图能够很好的归一化，比如256个bin条，那么即使是不同分辨率的图像都可以直接通过其直方图来计算相似度，计算量适中。比较适合描述难以自动分割的图像
"缺点"：直方图反应的是图像灰度值得概率分布，并没有图像的空间位置信息在里面，因此，常常出现误判；从信息论来讲，通过直方图转换，信息丢失量较大，因此单一的通过直方图进行匹配显得有点力不从心
"直方图均衡化"处理的“中心思想”是把原始图像的灰度直方图从比较集中的某个灰度区间变成在全部灰度范围内的均匀分布。直方图均衡化就是对图像进行非线性拉伸，重新分配图像像素值，使一定灰度范围内的像素数量大致相同。直方图均衡化就是把给定图像的直方图分布改变成“均匀”分布直方图分布.这样的图像往往有高对比度和多变的灰度色调,使图像更加清晰
~~~

#### 基于特征点的方法：

~~~python 
统计两个图像patch中匹配的特征点数，如果相似的特征点数比例最大，则认为最相似，最匹配.
方法优点：能被选作特征点的大致要满足不变性，尺度不变性，旋转不变等。这样图像的相似度计算也就具备了这些不变性。
方法缺点：特征点的匹配计算速度比较慢，同时特征点也有可能出现错误匹配的现象。
~~~

#### 图像模板匹配

~~~python
一般而言，源图像与模板图像patch尺寸一样的话，可以直接使用上面介绍的图像相似度测量的方法；如果源图像与模板图像尺寸不一样，通常需要进行滑动匹配窗口，扫面个整幅图像获得最好的匹配patch。
模板匹配：是一种在源图像中寻找与图像patch最相似的技术，常常用来进行目标的识别、跟踪与检测。其中最相似肯定是基于某种相似度准则来讲的，也就是需要进行相似度的测量。另外，寻找就需要在图像上进行逐行、逐列的patch窗口扫描，当然也不一定需要逐行逐列的扫描，当几个像素的误差比计算速度来的不重要时就可以设置扫描的行列步进值，以加快扫描和计算的时间消耗。下面就对相似度测量和模板匹配进行介绍（所有的图像都假定是灰度图）。
~~~

#### FILTER

~~~python
"图像滤波"，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。目的：1、消除图像中混入的噪声；2、为图像识别抽取出图像特。要求：1、不能损坏图像轮廓及边缘 ；2、图像视觉效果应当更好。
滤波和模糊的"区别"：拿高斯滤波来举例：滤波一般可以分为高通滤波和低通滤波，对于高斯低通滤波就会产生模糊效果，对于高斯高通滤波就会产生锐化的效果。所以通常是：高斯滤波就是指使用高斯函数进行滤波；高斯模糊就是指低通滤波。
高通：边缘增强、边缘提取 ；低通：钝化图像、去除噪音 ；带通：删除特定频率、增强中很少用
"线性滤波器"：在图像处理中，对邻域中的像素的计算为线性运算时，如利用窗口函数进行平滑加权求和的运算，或者某种卷积运算，都可以称为线性滤波。常见的线性滤波有：均值滤波(normalized box filter)、高斯滤波、盒子滤波、拉普拉斯滤波等等，通常线性滤波器之间只是模版系数不同。
"非线性滤波"：非线性滤波利用原始图像跟模版之间的一种逻辑关系得到结果，如最值滤波器，中值滤波器。比较常用的有中值滤波器和双边滤波器(bilateral filter),中值滤波用测试像素周围邻域像素集中的中值代替原像素。中值滤波去除椒盐噪声和斑块噪声时，效果非常明显.双边滤波在平滑图像时能够很好的保留边缘特性，但是其运算速度比较慢
~~~

#### EDGE DETECTING

~~~PYTHON
Robert：边缘定位精度较高，对于陡峭边缘且噪声低的图像效果较好，但没有进行平滑处理，没有抑制噪声的能力。

sobel和prewitt：进行了平滑处理，对噪声具有一定抑制能力，但容易出现多像素宽度。精度不高，边缘较粗糙。

Laplacian：对噪声较为敏感，使噪声能力成分得到加强，容易丢失部分边缘方向信息，造成一些不连续的检测边缘，抗噪声能力较差。

log：抗噪声能力较强，但会造成一些尖锐的边缘无法检测到。

canny：最优化思想的边缘检测算子，同时采用高斯函数对图像进行平滑处理，但会造成将高频边缘平滑掉，造成边缘丢失，采用双阈值算法检测和连接边缘
~~~

#### 形态学

~~~ python
"形态学"是图像处理中应用最为广泛的技术之一，主要用于从图像中提取对表达和描绘区域形状有意义的图像分量，使后续的识别工作能够抓住目标对象最为本质〈最具区分能力－most discriminative）的形状特征，如边界和连通区域等。同时像细化、像素化和修剪毛刺等技术也常应用于图像的预处理和后处理中，成为图像增强技术的有力补充。
膨胀、腐蚀、开、闭运算是数学形态学最基本的变换
腐蚀和膨胀的主要功能：（1）消除噪声（2）分割出独立的图像元素，在图像中连接相邻的元素（3）寻找图像中的极大值或者极小值区域（4）求出图像的梯度
"膨胀的作用",和腐蚀相反， 膨胀能使物体边界扩大， 具体的膨胀结果与图像本身和结构元素的形状有关。膨胀常用于将图像中原本断裂开来的同一物体桥接起来， 对图像进行二值化之后， 很容易使一个连通的物体断裂为两个部分， 而这会给后续的图像分析（如要基于连通区域的分析统计物体的个数〉造成困扰，此时就可借助膨胀桥接断裂的缝隙
"开运算"：开运算是先腐蚀后膨胀。主要用于消除小物体，在纤细点处分离物体，并且在平滑较大物体的边界的同时不明显改变其面积，同时抑制比结构元小的亮细节
"闭运算"：是先膨胀后腐蚀。用来填充物体内细小空洞、连接邻近物体、平滑其边界的同时并不明显改变其面积，同时抑制比结构元小的暗细节
"形态学梯度"：就是将膨胀图和腐蚀图相减。对二值化图像进行这一操作可以将边缘突出来，可以使用形态学梯度来保留物体的边缘轮廓
"顶帽变换"：就是用源图像减去开运算图像。因为开运算带来的结果是放大了裂缝或者局部低亮度的区域。因此，从原图中减去开运算后的图，得到的效果图突出了比原图轮廓周围区域更明亮的区域。顶帽一般用于校正不均匀光照的影响（补充：均匀光照在从背景中提取目标的处理中扮演核心的角色）。
"黑帽变换"：就是用闭运算减去源图像。黑帽运算后的效果图突出了比原图轮廓周围的区域更暗的区域。黑帽运算一般用来分离比邻近点暗一些的斑块
~~~

#### 图像金字塔

~~~python 
是图像中多尺度表达的一种，最主要用于图像分割，融合，是一种以多分辨率来解释图像的有效但概念简单的结构。一幅图像的金字塔是一系列以金字塔形状排列的，分辨率逐步降低且来源于同一张原始图的图像集合。其通过梯次向下采样获得，直到到达某个终止条件才停止采样。金字塔的底部是待处理图像的高分辨率表示，而顶部是低分辨率的近似。层级越高图像越小，分辨率越低
"拉普拉斯金字塔"(Laplaican pyramid)-用来从金字塔底层图像重建上层未采样的还原，在数字图像处理中也即是预测残差，可以对图像进行最大程度的还原，配合高斯金字塔一起使用，是从金字塔底层图像中向上采样，重建一个图像。
"高斯金字塔"是通过高斯平滑和亚采样获得一些采样图像，即是第K层高斯金字塔通过平滑、亚采样就可以获得第K+1层高斯图像。高斯金字塔包括一些列的低通滤波器，其截止频率从上一层到下一层以因子2逐渐增加，所以高斯金字塔可以跨越很大的频率范围。用来向下采样，主要用来向下采样图像,高斯金字塔是由底部的最大分辨率图像逐次向下采样得到的一系列图像。最下面的图像分辨率最高，越往上图像分辨率越低。
~~~

#### 二值化

~~~ python
"全局二值化"：一幅图像包括目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，最常用的方法就是设定一个全局的阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。将大于T的像素群的像素值设定为白色（或者黑色），小于T的像素群的像素值设定为黑色（或者白色）.全局二值化，在表现图像细节方面存在很大缺陷。为了弥补这个缺陷，出现了局部二值化方法
"局部二值化"的方法就是按照一定的规则将整幅图像划分为N个窗口，对这N个窗口中的每一个窗口再按照一个统一的阈值T将该窗口内的像素划分为两部分，进行二值化处理。局部二值化也有一个缺陷,存在于那个统一阈值的选定。这个阈值是没有经过合理的运算得来，一般是取该窗口的平局值。这就导致在每一个窗口内仍然出现的是全局二值化的缺陷。为了解决这个问题，就出现了局部自适应二值化方法
"局部自适应二值化"该方法就是在局部二值化的基础之上，将阈值的设定更加合理化。该方法的阈值是通过对该窗口像素的平均值E，像素之间的差平方P，像素之间的均方根值Q等各种局部特征，设定一个参数方程进行阈值的计算，例如：T=a*E+b*P+c*Q，其中a,b,c是自由参数。这样得出来的二值化图像就更能表现出二值化图像中的细节。
根据阈值选取的不同，二值化的算法分为"固定阈值"和"自适应阈值"。 比较常用的二值化方法则有：双峰法、P参数法、迭代法和OTSU法等
~~~

#### 霍夫变换

~~~python
霍夫变换是图像处理中用来从图像中分离出具有某种相同特征的几何形状（通常，直线，圆等）的常用方法。经典的霍夫变换常用来检测直线，圆，椭圆等。它是利用图像全局特性而将边缘像素连接起来组成区域封闭边界的一种方法。在预先知道区域形状的条件下，利用霍夫变换可以方便地得到边界曲线而将不连续的边缘像素点连接起来。霍夫变换的主要优点是受噪声和曲线间断的影响小。利用霍夫变换还可以直接检测某些已知形状的目标。
~~~

#### 仿射变换

~~~python
仿射变换（Affine Transformation）是空间直角坐标系的变换，从一个二维坐标变换到另一个二维坐标，仿射变换是一个线性变换，他保持了图像的“平行性”和“平直性”，即图像中原来的直线和平行线，变换后仍然保持原来的直线和平行线，仿射变换比较常用的特殊变换有平移(Translation)、缩放（Scale）、翻转（Flip）、旋转（Rotation）和剪切(Shear)。
~~~

#### 图像匹配

~~~python
目前图像匹配中，局部特征匹配占据了绝大部分，常用的局部特征匹配方法有Harris、SIFT、SURF、ORB等等，不同的特征点检测和匹配方法尤其独特的优势和不足.
 特征检测、特征选择、特征提取、特征描述和特征匹配

       特征检测： 根据用户的需求在图像中寻找满足定义的特征，包括角点、Blob点和边缘点。检测的结果：有或没有。

       特征选择： 为了选择稳定和可靠的特征，在检测到的特征集合中，需要进一步约束，通过类似于非极大值抑制、对比度阈值约束等条件保留显著特征。选择的结果：特征子集。

       特征提取： 特征选择确定稳定可靠的特征子集后，需要提取特征的位置（Location）、方向（Orientation）和尺度（Scale）信息。方向和尺度信息主要是为支持旋转和尺度变化。

       特征描述： 结合特征（点）邻域信息，使用一定的描述规则来对特征区域进行量化并抽取能代表该特征的描述信息，为了后续的匹配，一般用特征向量（feature vector）表示。

      特征匹配： 对提取到的特征，需要通过使用一定的方法来进一步判断对应的特征是否相同（或近似），对特征向量一般使用欧式距离或最邻近距离比（NNDR）进行判定，满足一定的条件约束，则认为两个特征相近，否则剔除。一般还会通过RANSAC进一步约束剔除误匹配点。   
~~~

~~~python
declaration:内容来自于：https://blog.csdn.net/dajiyi1998/article/details/80238297?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161354265516780271560223%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161354265516780271560223&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-80238297.first_rank_v2_pc_rank_v29&utm_term=%25E5%259B%25BE%25E5%2583%258F%25E5%25A4%2584%25E7%2590%2586
~~~

