### Object  oriented  programming

### 1-1:  什么是面向对象  ？

封装

继承

多态

***\*JVM 内存结构\****：

堆  栈  方法区  heap stack method area;

\1. 堆 ：

Jvm 在内存空间开辟一个称为堆的存储空间，这部分空间用于存储使用 new 关键字创建的对象实例；

\2. 栈：

用于存放程序运行过程中所有的局部变量，一个运行的程序从开始到结束会有多次的方法调用。Jvm 为每一个方法的调用在栈中分配一个对应的空间，这个空间叫做方法的栈针。一个栈针对应一个正在调用的方法，栈针中存储了该方法的参数，局部变量等数据，当一个方法调用结束后，那么栈针就会清除；

\3. 方法区：

该空间存放了类的信息，java程序运行时，首先会通过装载器载入类文件的字节码信息，经过解析后将其装入方法区，类的各种信息都在方法区中保存；

 

类，对象，引用 class object reference；

### 什么是类？

类是一个抽象的定义概念，简单说就是分类，类定义了一个类型对象的数据结构，也就是成员变量，同时也定义了类的调用功能，也就是我们说的方法。类是构建对象的模板，决定这个类的数据结构。

类定义了之后，我们可以使用new运算来创建一个类的对象，这个对象的创建过程就是我们说的类的实例化。在对象创建之后，成员变量具有默认的初始化值，数值类型为0，Boolean 类型是false，char类型是/u0000,引用类型为null。

 

​	***\*public\**** ***\*static\**** ***\*void\**** main(String[] args) {

​		Test t=***\*new\**** Test();// 类的实例化；

​		t.name="gary";

​		t.age=20;

​		t.address="henan";

​		String name=t.print();

​		System.***\**out\**\***.println(name);

​		

​	}

​	

}

***\*class\**** Test  {

​	// 成员变量；

​	String name;

​	***\*int\**** age;

​	String address;

// 类方法

​	***\*public\**** String print() {

​		***\*return\**** name+","+age+","+address;

​	}

​	

}

 

 

***\*成员变量的初始化\****：  默认初始值：

基本类型 0 ；

Boolean： false ；

Char：  /u000;

引用类型： null;

***\*引用类型\****：除了八种基本类型外，用类名（接口数组）声明的变量称为引用类型变量，简称“引用”

使用某个类名声明的引用类型变量可以存储该类对象的地址信息，通常称为“指向该类型的对象”当一个引用类型变量指向该类的对象时，就可以通过这个变量对对象实施访问；引用类型变量中存储的是某个对象在内存中的地址信息，引用的功能在于通过这个地址信息访问对象。

引用类型可为null 表示不指向任何的对象， 但同时他也不可以访问成员变量或者调用方法 否则会产生 NullPointException

***\*方法的定义和调用\****definition and invocation

 必须通过某个对象的引用，当通过这个对象的引用调用方法时，方法中涉及的成员变量就是该对象的成员变量，在方法中用this代表这个对象， 谁调用方法，this就代表的谁。

***\*方法的重载：\****

Java语言中，允许多个方法的名称相同，但是参数列表不同，称之为方法的重载 overload ；编译期根据参数的不同，绑定不同的方法。

 

***\*This\**** 是因为，一个类中可以创建多个对象，但是方法只用一份，所以我们需要this 来指代当前调用的对象，本质上this就是代词，指代调用的当前对象；

 

 

​	***\*public\**** ***\*static\**** ***\*void\**** main(String[] args) {

​		Test t=***\*new\**** Test();// 类的实例化 可以有多对象

​		***\*int\**** a=t.add(1);//方法中的this 代表的是这个t。

​		System.***\**out\**\***.println(a);

​	}

​	

}

***\*class\**** Test {

​	***\*int\**** x=0;

​	***\*int\**** y=0;

​	***\*int\**** n=2;

​	// overload of method;方法的重载；

​	***\*public\**** ***\*int\**** add() {// no parameter;

​	***\*return\**** x;

​	}

​	***\*public\**** ***\*int\**** add(***\*int\**** x) { // get parameter;

​		***\*this\****.x=x;//this 调用该方法的对象，谁调用就是指谁；在没有歧义的情况下 this 可以省略；

​		x++;

​		***\*return\**** x;

​	}

​	***\*public\**** ***\*void\**** minus(***\*int\**** y) {

​		***\*this\****.y=y;

​		y-=n;

​	}

}	

***\*构造方法 ： construction ：\****

在java语言中通过构造方法实现对象的成员变量的初始化。构造方法在类中定义方法，构造方法和一般方法有所不同，

1.构造方法的名称和类名字相同；

2.构造方法没有返回值，也不能写void ；

任何一个编译后的类都必须包含构造方法，如果程序中没有定义，那么编译器在编译时会默认添加一个无参构造，

 

​	***\*public\**** ***\*static\**** ***\*void\**** main(String[] args) {

​		Test t=***\*new\**** Test(5);// 构造方法对类成员变量进行了初始化 有参构造；

​		System.***\**out\**\***.println(t.add(2));

​	}

​	

}

***\*class\**** Test {

​	***\*int\**** x;

​	//构造方法  以及构造方法的重载；

​	Test(){// 若没有写构造方法 默认有这个一个无参构造；构造方法是为了对类的成员变量初始化；

​		

​	}

​	Test(***\*int\**** x){// 构造方法的重写；

​		***\*this\****.x=x;

​	}	

​	// Test 类方法  以及overload of method;方法的重载；

​	***\*public\**** ***\*int\**** add() {// no parameter;

​	***\*return\**** x;

​	}

​	***\*public\**** ***\*int\**** add(***\*int\**** x) { // get parameter;

​		***\*return\**** ***\*this\****.x+x;

​	}

​	

}

 

方法的签名 就是方法名相同，参数列表不同的方法，同一个类没有方法名完全相同的签名；

 

 

 

 

### ***\*继承：inheritance\****

什么是继承？

父与子的关系。Sub_class  super_class , 

子类可以继承父类的成员变量和成员方法，同时也可以定义自己的成员变量和方法；

同时继承具有单一性， 一个类只能继承一个父类 但是一个父类可以有多个子类；

通过extends 关键字实现类的继承；

向上造型：

一个子类的对象可以向上造型为父类的类型；就是父类的引用变量可以引用子类型的实例；

 

​	// inheritance;

​	***\*public\**** ***\*static\**** ***\*void\**** main(String[] args) {

​		Father f=***\*new\**** Father();// new 一个父类的对象 blood为 B 

​		f.work();// 调用父类的work 方法；

​		System.***\**out\**\***.println("父亲的血型"+f.blood);// 父类的血型；

​		//======================================

​		Son s=***\*new\**** Son();// 创建一个son的引用s指向son对象

​		s.print(); 

​		s.work();

​		System.***\**out\**\***.println("儿子的血型："+s.blood);

​		// 向上构造；以及向上构造的意义 demonstration 向上构造多态化，work这一个方法，可以让不同的让人去调用；

​		Father f1=***\*new\**** Son();// 向上构造了，父类的引用指向了子类的对象；】、

​		f1.work();

​		System.***\**out\**\***.println("构造儿子"+f1.blood);// 儿子继承的血型 

​		

​		// 女儿的向上构造；

​		Father f2=***\*new\**** Daughter();

​		f2.work();

​		System.***\**out\**\***.println("构造女儿"+f2.blood);

​	/*总结：

​	 * 本代码介绍了什么是继承，如何继承，继承中的重写，向上构造，以及向上构造的意义。（不同对象可以通过继承，向上构造调用方法。提高代码的复用性）

​	 * 

​	 */

​	}

​	

}

***\*class\**** Father {// superclass 

​	String blood="B" ;//成员变量

​	***\*public\**** ***\*void\**** work() {

​		System.***\**out\**\***.println("father is working");

​	}

}

***\*class\**** Son ***\*extends\**** Father{//sub class extends father

​	***\*public\**** ***\*void\**** work () {//方法的重写 override ：因为父类定义的方法并不一定满足我们子类的需求 所以我们需要重写；

​		System.***\**out\**\***.println("son is studing ");

​	}

​	***\*public\**** ***\*void\**** print () {

​		System.***\**out\**\***.println("im a son"); 

​	}

​	

}

***\*class\**** Daughter ***\*extends\**** Father {

​	***\*public\**** ***\*void\**** work () {

​		System.***\**out\**\***.println("im a little girl,drink milk ");

​	}

​	}

***\*继承中的构造方法\****：

子类的构造方法必须通过super关键字调用父类的构造方法，可以妥善的初始化来自父类的成员变量；

Instanceof 关键字:

对于一个父类的引用类型，可以指向该类的对象，也可以指向任意一个子类的对象。通过instanceof 关键字判断指向的对象的实际类型；

![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml15176\wps3.jpg) 

 

​		/*

​		 * 创建了两个类的对象， instanceof 是判断引用类性是否是这个类的实例，

​		 * 就是説这个引用类性是不是这个类的实现；

​		 */

​		Shape s=***\*new\**** Shape();

​		Circle c=***\*new\**** Circle();

​		***\*if\**** ( c ***\*instanceof\**** Shape ) {

​			System.***\**out\**\***.println("true");

​		}***\*else\**** {

​			System.***\**out\**\***.println(***\*false\****);

​		}

### 	***\*方法的重写和重载的区别：\****

方法的重载：

在一个类中，方法名相同，参数列表不同，我们称他们是方法的重载；

在编译器中 会根据不同参数列表绑定不同的方法。

方法的重写 ：

在继承方法中，父类所定义的方法。在子类继承的时候一并继承给子类，但是子类对父类的方法有不同的需求，这个时候我们把这个方法重写 ，以达到我们的需求。

​	

 

 

 

 

 

### ***\*访问控制： access control\****

Public 和private 

Private 修饰的成员变量和方法只能在本类中调用  是对内的封装，

Public 修饰的成员变量和方法可以在任何（同包？）地方调用  修饰的内容是为了对本类外的方法或者类来调用的，

Package 语句：

定义类的时候需要指定类的名字，我们通过包名+类名来避免命名冲突问题 

Package 语句一般写在java源文件的开始位置，在类定义之前，

***\*package\**** practice;

Import语句：

访问一个类的时候需要这个类的全称声明，

例如：

***\*import\**** java.util.Arrays;

通过import声明之后，该源文件就可以直接使用类名来访问该类

Protected 和默认访问权限：

被protected修饰的成员变量和方法可以被子类和同包类使用，默认的访问权限就是被同一包中的类调用；

![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml15176\wps4.jpg) 

 

Static 和 final 关键字 修饰成员变量；

Static修饰的成员变量不属于对象的数据结构；

Static变量属于类的变量，通常通过类名来引用static成员

Static 成员变量和类信息一起存储在方法区中，只有一份，无论该类创建了多少对象；

package:声明一个包， 包为了解决类名的冲突；同一个包中可以类名不同，不同的类名可以不同；建议所有字母小写；

​		 import:访问一个类时，需要该类的全称，可以通过import语句对类的全程进行声明； import 包名+类型；声明之后该源文件可以通过类名访问这个类；

​		 * 访问控制修饰符：

​		 * public：公开的 任何类

​		 * private： 私有的，本类

​		 * protected：受保护的，本类，子类，同包类

​		 * 默认的：什么也不写 本类 同包类

​		 * 建议数据私有化， 行为方法公有化；

​		 * static:静态的  修饰变量 ，方法，静态块

​		 * 静态变量： StaticDemo static int a; 成员变量分为实例对象（有几个对象有几个变量）和静态对象  （由static 修饰 ，属于类 ，存在方法区中通过 类名.变量名 访问）

​		 *  每次声明一个对象 那么就是在堆中 创建一个新的对象 并且包含有对象的属性和方法；

​		 *  b 是静态变量。属于类 存在与方法体中，只有一份 和对象无关 和方法有关 所有每次改变就是在变化后的基础上

​		 * 静态方法和普通方法的差别：

​		 * 静态方法中没有隐式的this 因此静态方法中不能访问实例变量（必须通过对象访问）

​		 * 使用 ： 静态方法的使用仅与参数相关与对象无关  例如  arrsys.sort (arr); Math.random();

​		 * 静态块：由static 修饰  属于类 ，类在加载期间执行的代码块，只执行一次。可以用来加载静态资源。  例如游戏进行前的加载资源；其实就是在加载静态块 例如游戏开始前的图片地图等；

​		 * final:不能改变  修饰成员变量（不能改变初始化时赋值） 方法 （不能重写） 类（不能继承）；

​		 * static final 常量（还是代词  即是由他们两者修饰的）；必须声明的同时 初始化，不可改变；常量名所有字母大写；

 

 

### ***\*抽象类和抽象方法\**** ***\*：\****

由abstract 修饰的类叫做抽象类，其中肯定包含抽象方法，抽象类不能实例化，抽象类的意义在于被继承，抽象类为子类抽象出了公共的部分，通常也定义了子类所必须具体实现的抽象方法；

 

抽象方法： abstract void xx (){} 相当于把抽象方法的方法体抽象出来，给子类用来继承和重写，以满足不同子类的方法需求，

抽象方法只有方法的定义 没有方法的实例化；

方法抽象了之后 所在的类也就必须抽象化了；

​	// inheritance;abstract class 

​	***\*public\**** ***\*static\**** ***\*void\**** main(String[] args) {

​		AbDemo a =***\*new\**** AsDemo1(5);// 向上造型；

​		a.sdemo();

​	}

}

 ***\*abstract\**** ***\*class\**** AbDemo{// 抽象类 

​	***\*int\**** x;

​	// 构造方法 ：

// 抽象方法；没有方法体 不能实例化

​	***\*abstract\**** ***\*void\**** sdemo();

}

 // 创建子类继承了抽象类 抽象方法需要重写进行实例化；

***\*class\**** AsDemo1 ***\*extends\**** AbDemo{

​	AsDemo1(){

​	}

​	AsDemo1(***\*int\**** x){

​		***\*this\****.x=x;

​	}

***\*void\**** sdemo () {

 

System.***\**out\**\***.println(x*100);// 不同的子类可以有不同的实现 再创建一个子类 可以再重写一个方法 

​	}

}

 

 

### ***\*对象数组：\****

所谓的对象数组就是对象的元素不是基本类型，而是引用类型；

对象数组的初始化：

对象数组的初始化和基本类型的初始化基本一致，只是元素是对象的引用 所以对象数组元素的默认值是null；

数组类型数组：

数组的元素可以是任何类型的，也包括数组类型 （即是二维数组）

数组类型数组的初始化：

 

​	// 引用类型数组；arr 数组 有三个数组元素 每个数组元素有四个数组元素； 

​	***\*int\**** [][] arr =***\*new\**** ***\*int\****[3][4];// 数组的数组 三行四列；

​	

​	// 遍历 嵌套循环

​	***\*for\****(***\*int\**** i=0;i<arr.length;i++){

​		***\*for\**** (***\*int\**** j=0;j<arr[i].length;j++) {

​			System.***\**out\**\***.print("=");

​		}

​		System.***\**out\**\***.println();

​	}

 

====

====

====



### ***\*接口：\****

什么是接口？

接口可以看成特殊的抽象类，就是只包含抽象方法的抽象类

接口中不可以定义成员变量，但是可以定义常量；

怎么实现？

一个类可以通过implements关键字实现接口，一个类实现一个接口后必须 实现这个接口定义的所有方法。与继承不同，一个类可以实现多个接口，直接用逗号分隔开就可以了。

同时接口可以作为一个类型声明变量，一个接口的类型的变量可以引用实现了该类接口的类的对象，通过该变量调用接口中定义的方法 

接口之间存在继承关系，一个接口通过extends 可以继承其他的接口，子接口继承了所有父接口中定义的方法；

接口的意义?

接口的定义可以使不同的对象进行实现该接口。使得该接口具有多种形态供多个对象实现使用。接口就是一种类似行业标准 让不同的对象去遵守；

多态：多态是面向对象的一个重要特征，任何一个对象其实在不同的场合，不同的时间段，具有不同的属性和行为。我们把这种情况称为多态。

​	/*

​	 * 创建一个接口 inter 一个类 Cla 

​	 * 主要阐述关于接口的继承，接口的实现， 

​	 */

​		inter inte=***\*new\**** Cla();// 接口作为一种类型声明变量；

​		inte.eat();	

}

}

// 接口的定义 内部是抽象方法，不能定义具体的行为 ，供其他类实现；

***\*interface\**** inter {

​	***\*public\**** ***\*static\**** ***\*final\**** ***\*int\**** ***\**MEAL\**\***=3;// 定义一个常量，表示一日三餐 ；类型循环的限定条件

​	***\*public\**** ***\*void\**** eat() {

}

 

// 接口继承接口

***\*interface\**** inter2 ***\*extends\**** inter{

​	***\*public\**** ***\*void\**** run();

}

***\*class\**** Cla ***\*implements\**** inter2 {

​	***\*public\**** ***\*void\**** run() {// 接口继承需要重写抽象方法

​		

​	}

​	***\*public\**** ***\*void\**** eat() {

​		System.***\**out\**\***.println("吃饭时间到了");

​		***\*long\**** time=System.**currentTimeMillis**();

​		***\*for\**** (***\*int\**** i=1;i<=***\**MEAL\**\***;i++) {

​			System.***\**out\**\***.println("第"+i+"餐开始了..."+time);

​			time+=100;// 间隔用餐时间；

​		}	

​	}

}

### ***\*内部类和匿名类：\****

内部类定义Inner class ：

一个类定义在另一个类的内部，称之为内部类 inner 

所在的类叫做外部类 outer

内部类一般只服务于外部类，对外部（外部类）具有可见性，

内部类的应用：

当一个类的存在价值仅仅是为了为一个类服务 ，这个时候我们把这个服务类定义为内部类；内部类可以方便地访问他的外部类的私有属性；

***\*public\**** ***\*static\**** ***\*void\**** main(String[] args) {

​	/*

​	 * 内部类的定义 应用

​	 */

outer o=***\*new\**** outer();

o.start();

o.print();

}

 

***\*class\**** outer {

​	***\*private\**** ***\*int\**** time;

​	***\*private\**** Timer timer =***\*new\**** Timer();

​	 ***\*int\**** count=3;

​	***\*public\**** ***\*void\**** start() {

​	// 时间控制方法， 1000毫秒执行一次inner 的内容，

​			timer.schedule(***\*new\**** inner(),0,1000);	

​		}

​	***\*public\**** ***\*void\**** print() {

​		System.***\**out\**\***.println(time);

​	}

​		

​	}

​	***\*class\**** inner ***\*extends\**** TimerTask{

​		***\*public\**** ***\*void\**** run() {

​			System.***\**out\**\***.print("=");

​			

​		}

​	

}

 

### ***\*匿名内部类anonymous：\****

如果一段程序中需要创建一个类的对象（通常需要继承或者实现接口），对象创建后这个类的价值就不在了，这个时候这个类可以不用命名，称之为匿名内部类；

匿名内部类应用在接口回调，事件监听等；

接口回调就是如果一个方法的参数是接口类型，那么在调用这个方法的时候，需要创建并传递一个实现这个接口类型的对象，而该方法在运行时会调用到参数对象中的实现的方法；

