### DIP concepts

####   convolution and linear filter

~~~ python
线性滤波可以说是图像处理最基本的方法， 它可以允许我们对图像进行处理，产生不同的效果。 
1.首先我们创建一个二维滤波器矩阵（卷积核）， 和一个需要处理的二维图像，然后我们对于图像的每一个像素点，计算它和邻域像素和卷积核的对应元素的乘积，最后加起来作为该元素的值， 这就是我们说的滤波过程。见convolution图 
对图像和滤波矩阵进行逐个元素相乘再求和的操作就相当于将一个二维的函数移动到另一个二维函数的所有位置，这个操作就叫卷积或者协相关。卷积和协相关的差别是，卷积需要先对滤波矩阵进行180的翻转，但如果矩阵是对称的，那么两者就没有什么差别了。
2.correlation 和 convolution 两个非常关键的特点：它们是线性的，而且具有平移不变性shift-invariant。平移不变性指我们在图像的每个位置都执行相同的操作。线性指这个操作是线性的，也就是我们用每个像素的邻域的线性组合来代替这个像素。这两个属性使得这个操作非常简单，因为线性操作是最简单的，然后在所有地方都做同样的操作就更简单了。
3.对于滤波器具有一定的规则要求：
(1)滤波器的大小应该是"奇数"，这样它才有一个中心，例如3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。
(2)滤波器矩阵所有的元素之和应该要"等于1"，这是为了保证滤波前后图像的亮度保持不变。当然了，这不是硬性要求了。
(3)如果滤波器矩阵所有元素之和"大于1"，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗.
(4)对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。
4.卷积的相关操作：锐化，模糊
如果滤波器的中心点是1， 其他邻域点的权值是0，那么在滤波后没有任何影响，因为邻域的值为0 相加之后没有对中心点的值产生任何影响。
（1）图像锐化：
图像的锐化和边缘检测很像，首先"找到边缘"，然后把"边缘加到原来的图像上面"，这样就强化了图像的边缘，使图像看起来更加锐利了。这两者操作统一起来就是锐化滤波器了，也就是在边缘检测滤波器的基础上，再在中心的位置加1，这样滤波后的图像就会和原始的图像具有同样的亮度了，但是会更加锐利。
（2）边缘检测
我们要找水平的边缘：需要注意的是，这里矩阵的元素和是0，所以滤波后的图像会很暗，只有边缘的地方是有亮度的。为了检测边缘，我们需要在图像对应的方向计算梯度。但在实际中，这种简单的方法会把噪声也放大了。
（3）均值模糊
我们可以将当前像素和它的四邻域的像素一起取平均，然后再除以5，或者直接在滤波器的5个地方取0.2的值即可
（4）高斯模糊
其实模糊滤波器就是对周围像素进行加权平均处理，均值模糊很简单，周围像素的权值都相同，所以不是很平滑。高斯模糊使用了模糊器的优点，所以被广泛用在图像降噪上。特别是在边缘检测之前，都会用来移除细节。那么下面我们就看看高斯模糊的权值是如何分配的。
declaration：https://blog.csdn.net/weixin_42026802/article/details/80181627?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161354265516780271560223%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161354265516780271560223&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-80181627.first_rank_v2_pc_rank_v29&utm_term=%25E5%259B%25BE%25E5%2583%258F%25E5%25A4%2584%25E7%2590%2586


~~~

#### HISTOGRAM

~~~ PYTHON
直方图：一幅图像由不同灰度值的像素组成，图像中灰度的分布情况是该图像的一个重要特征。图像的灰度直方图就描述了图像中灰度分布情况，能够很直观的展示出图像中各个灰度级所占的多少。图像的灰度直方图是灰度级的函数，描述的是图像中具有该灰度级的像素的个数：其中，横坐标是灰度级，纵坐标是该灰度级出现的频率。
histogram normalization:直方图归一化：有些灰度图像的像素并没有分布在 [0,255] 内，而是分布在 [0,255] 的子区间内。这样的图像肉眼看上去往往不是很清晰。我们可以通过直方图归一化的方式，将它的像素分布从 [0,255] 的子区间变为 [0,255] 范围内。通过这样的方式，往往可以增加图像的清晰度
"直方图的优点"：直方图能够很好的归一化，比如256个bin条，那么即使是不同分辨率的图像都可以直接通过其直方图来计算相似度，计算量适中。比较适合描述难以自动分割的图像
"缺点"：直方图反应的是图像灰度值得概率分布，并没有图像的空间位置信息在里面，因此，常常出现误判；从信息论来讲，通过直方图转换，信息丢失量较大，因此单一的通过直方图进行匹配显得有点力不从心
"直方图均衡化"处理的“中心思想”是把原始图像的灰度直方图从比较集中的某个灰度区间变成在全部灰度范围内的均匀分布。直方图均衡化就是对图像进行非线性拉伸，重新分配图像像素值，使一定灰度范围内的像素数量大致相同。直方图均衡化就是把给定图像的直方图分布改变成“均匀”分布直方图分布.这样的图像往往有高对比度和多变的灰度色调,使图像更加清晰
~~~

#### 基于特征点的方法：

~~~python 
统计两个图像patch中匹配的特征点数，如果相似的特征点数比例最大，则认为最相似，最匹配.
方法优点：能被选作特征点的大致要满足不变性，尺度不变性，旋转不变等。这样图像的相似度计算也就具备了这些不变性。
方法缺点：特征点的匹配计算速度比较慢，同时特征点也有可能出现错误匹配的现象。
~~~

#### 图像模板匹配

~~~python
一般而言，源图像与模板图像patch尺寸一样的话，可以直接使用上面介绍的图像相似度测量的方法；如果源图像与模板图像尺寸不一样，通常需要进行滑动匹配窗口，扫面个整幅图像获得最好的匹配patch。
模板匹配：是一种在源图像中寻找与图像patch最相似的技术，常常用来进行目标的识别、跟踪与检测。其中最相似肯定是基于某种相似度准则来讲的，也就是需要进行相似度的测量。另外，寻找就需要在图像上进行逐行、逐列的patch窗口扫描，当然也不一定需要逐行逐列的扫描，当几个像素的误差比计算速度来的不重要时就可以设置扫描的行列步进值，以加快扫描和计算的时间消耗。下面就对相似度测量和模板匹配进行介绍（所有的图像都假定是灰度图）。
~~~

#### FILTER

~~~python
"图像滤波"，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。目的：1、消除图像中混入的噪声；2、为图像识别抽取出图像特。要求：1、不能损坏图像轮廓及边缘 ；2、图像视觉效果应当更好。
滤波和模糊的"区别"：拿高斯滤波来举例：滤波一般可以分为高通滤波和低通滤波，对于高斯低通滤波就会产生模糊效果，对于高斯高通滤波就会产生锐化的效果。所以通常是：高斯滤波就是指使用高斯函数进行滤波；高斯模糊就是指低通滤波。
高通：边缘增强、边缘提取 ；低通：钝化图像、去除噪音 ；带通：删除特定频率、增强中很少用
"线性滤波器"：在图像处理中，对邻域中的像素的计算为线性运算时，如利用窗口函数进行平滑加权求和的运算，或者某种卷积运算，都可以称为线性滤波。常见的线性滤波有：均值滤波(normalized box filter)、高斯滤波、盒子滤波、拉普拉斯滤波等等，通常线性滤波器之间只是模版系数不同。
"非线性滤波"：非线性滤波利用原始图像跟模版之间的一种逻辑关系得到结果，如最值滤波器，中值滤波器。比较常用的有中值滤波器和双边滤波器(bilateral filter),中值滤波用测试像素周围邻域像素集中的中值代替原像素。中值滤波去除椒盐噪声和斑块噪声时，效果非常明显.双边滤波在平滑图像时能够很好的保留边缘特性，但是其运算速度比较慢
~~~

#### EDGE DETECTING

~~~PYTHON
Robert：边缘定位精度较高，对于陡峭边缘且噪声低的图像效果较好，但没有进行平滑处理，没有抑制噪声的能力。

sobel和prewitt：进行了平滑处理，对噪声具有一定抑制能力，但容易出现多像素宽度。精度不高，边缘较粗糙。

Laplacian：对噪声较为敏感，使噪声能力成分得到加强，容易丢失部分边缘方向信息，造成一些不连续的检测边缘，抗噪声能力较差。

log：抗噪声能力较强，但会造成一些尖锐的边缘无法检测到。

canny：最优化思想的边缘检测算子，同时采用高斯函数对图像进行平滑处理，但会造成将高频边缘平滑掉，造成边缘丢失，采用双阈值算法检测和连接边缘
~~~

#### 形态学

~~~ python
"形态学"是图像处理中应用最为广泛的技术之一，主要用于从图像中提取对表达和描绘区域形状有意义的图像分量，使后续的识别工作能够抓住目标对象最为本质〈最具区分能力－most discriminative）的形状特征，如边界和连通区域等。同时像细化、像素化和修剪毛刺等技术也常应用于图像的预处理和后处理中，成为图像增强技术的有力补充。
膨胀、腐蚀、开、闭运算是数学形态学最基本的变换
腐蚀和膨胀的主要功能：（1）消除噪声（2）分割出独立的图像元素，在图像中连接相邻的元素（3）寻找图像中的极大值或者极小值区域（4）求出图像的梯度
"膨胀的作用",和腐蚀相反， 膨胀能使物体边界扩大， 具体的膨胀结果与图像本身和结构元素的形状有关。膨胀常用于将图像中原本断裂开来的同一物体桥接起来， 对图像进行二值化之后， 很容易使一个连通的物体断裂为两个部分， 而这会给后续的图像分析（如要基于连通区域的分析统计物体的个数〉造成困扰，此时就可借助膨胀桥接断裂的缝隙
"开运算"：开运算是先腐蚀后膨胀。主要用于消除小物体，在纤细点处分离物体，并且在平滑较大物体的边界的同时不明显改变其面积，同时抑制比结构元小的亮细节
"闭运算"：是先膨胀后腐蚀。用来填充物体内细小空洞、连接邻近物体、平滑其边界的同时并不明显改变其面积，同时抑制比结构元小的暗细节
"形态学梯度"：就是将膨胀图和腐蚀图相减。对二值化图像进行这一操作可以将边缘突出来，可以使用形态学梯度来保留物体的边缘轮廓
"顶帽变换"：就是用源图像减去开运算图像。因为开运算带来的结果是放大了裂缝或者局部低亮度的区域。因此，从原图中减去开运算后的图，得到的效果图突出了比原图轮廓周围区域更明亮的区域。顶帽一般用于校正不均匀光照的影响（补充：均匀光照在从背景中提取目标的处理中扮演核心的角色）。
"黑帽变换"：就是用闭运算减去源图像。黑帽运算后的效果图突出了比原图轮廓周围的区域更暗的区域。黑帽运算一般用来分离比邻近点暗一些的斑块
~~~

#### 图像金字塔

~~~python 
是图像中多尺度表达的一种，最主要用于图像分割，是一种以多分辨率来解释图像的有效但概念简单的结构。一幅图像的金字塔是一系列以金字塔形状排列的，分辨率逐步降低且来源于同一张原始图的图像集合。其通过梯次向下采样获得，直到到达某个终止条件才停止采样。金字塔的底部是待处理图像的高分辨率表示，而顶部是低分辨率的近似。层级越高图像越小，分辨率越低
~~~

